// Code generated by MockGen. DO NOT EDIT.
// Source: assignment (interfaces: HashService,TokenService,RevocationList,NonMatchingIPNotifier)
//
// Generated by this command:
//
//	mockgen -package mocks -destination mocks/services.go . HashService,TokenService,RevocationList,NonMatchingIPNotifier
//

// Package mocks is a generated GoMock package.
package mocks

import (
	domain "assignment"
	context "context"
	reflect "reflect"
	time "time"

	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockHashService is a mock of HashService interface.
type MockHashService struct {
	ctrl     *gomock.Controller
	recorder *MockHashServiceMockRecorder
	isgomock struct{}
}

// MockHashServiceMockRecorder is the mock recorder for MockHashService.
type MockHashServiceMockRecorder struct {
	mock *MockHashService
}

// NewMockHashService creates a new mock instance.
func NewMockHashService(ctrl *gomock.Controller) *MockHashService {
	mock := &MockHashService{ctrl: ctrl}
	mock.recorder = &MockHashServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHashService) EXPECT() *MockHashServiceMockRecorder {
	return m.recorder
}

// Compare mocks base method.
func (m *MockHashService) Compare(v, hash []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compare", v, hash)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Compare indicates an expected call of Compare.
func (mr *MockHashServiceMockRecorder) Compare(v, hash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compare", reflect.TypeOf((*MockHashService)(nil).Compare), v, hash)
}

// Hash mocks base method.
func (m *MockHashService) Hash(b []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Hash", b)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Hash indicates an expected call of Hash.
func (mr *MockHashServiceMockRecorder) Hash(b any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Hash", reflect.TypeOf((*MockHashService)(nil).Hash), b)
}

// MockTokenService is a mock of TokenService interface.
type MockTokenService struct {
	ctrl     *gomock.Controller
	recorder *MockTokenServiceMockRecorder
	isgomock struct{}
}

// MockTokenServiceMockRecorder is the mock recorder for MockTokenService.
type MockTokenServiceMockRecorder struct {
	mock *MockTokenService
}

// NewMockTokenService creates a new mock instance.
func NewMockTokenService(ctrl *gomock.Controller) *MockTokenService {
	mock := &MockTokenService{ctrl: ctrl}
	mock.recorder = &MockTokenServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenService) EXPECT() *MockTokenServiceMockRecorder {
	return m.recorder
}

// GenerateTokenPair mocks base method.
func (m *MockTokenService) GenerateTokenPair(claims domain.Claims) domain.IssuedTokens {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateTokenPair", claims)
	ret0, _ := ret[0].(domain.IssuedTokens)
	return ret0
}

// GenerateTokenPair indicates an expected call of GenerateTokenPair.
func (mr *MockTokenServiceMockRecorder) GenerateTokenPair(claims any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateTokenPair", reflect.TypeOf((*MockTokenService)(nil).GenerateTokenPair), claims)
}

// ValidateAccessToken mocks base method.
func (m *MockTokenService) ValidateAccessToken(tokenStr string) (domain.Claims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateAccessToken", tokenStr)
	ret0, _ := ret[0].(domain.Claims)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateAccessToken indicates an expected call of ValidateAccessToken.
func (mr *MockTokenServiceMockRecorder) ValidateAccessToken(tokenStr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAccessToken", reflect.TypeOf((*MockTokenService)(nil).ValidateAccessToken), tokenStr)
}

// ValidateAccessTokenIgnoringExpiration mocks base method.
func (m *MockTokenService) ValidateAccessTokenIgnoringExpiration(tokenStr string) (domain.Claims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateAccessTokenIgnoringExpiration", tokenStr)
	ret0, _ := ret[0].(domain.Claims)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateAccessTokenIgnoringExpiration indicates an expected call of ValidateAccessTokenIgnoringExpiration.
func (mr *MockTokenServiceMockRecorder) ValidateAccessTokenIgnoringExpiration(tokenStr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAccessTokenIgnoringExpiration", reflect.TypeOf((*MockTokenService)(nil).ValidateAccessTokenIgnoringExpiration), tokenStr)
}

// MockRevocationList is a mock of RevocationList interface.
type MockRevocationList struct {
	ctrl     *gomock.Controller
	recorder *MockRevocationListMockRecorder
	isgomock struct{}
}

// MockRevocationListMockRecorder is the mock recorder for MockRevocationList.
type MockRevocationListMockRecorder struct {
	mock *MockRevocationList
}

// NewMockRevocationList creates a new mock instance.
func NewMockRevocationList(ctrl *gomock.Controller) *MockRevocationList {
	mock := &MockRevocationList{ctrl: ctrl}
	mock.recorder = &MockRevocationListMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRevocationList) EXPECT() *MockRevocationListMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockRevocationList) Add(ctx context.Context, id uuid.UUID, expiresAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, id, expiresAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockRevocationListMockRecorder) Add(ctx, id, expiresAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockRevocationList)(nil).Add), ctx, id, expiresAt)
}

// Contains mocks base method.
func (m *MockRevocationList) Contains(ctx context.Context, id uuid.UUID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Contains", ctx, id)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Contains indicates an expected call of Contains.
func (mr *MockRevocationListMockRecorder) Contains(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Contains", reflect.TypeOf((*MockRevocationList)(nil).Contains), ctx, id)
}

// MockNonMatchingIPNotifier is a mock of NonMatchingIPNotifier interface.
type MockNonMatchingIPNotifier struct {
	ctrl     *gomock.Controller
	recorder *MockNonMatchingIPNotifierMockRecorder
	isgomock struct{}
}

// MockNonMatchingIPNotifierMockRecorder is the mock recorder for MockNonMatchingIPNotifier.
type MockNonMatchingIPNotifierMockRecorder struct {
	mock *MockNonMatchingIPNotifier
}

// NewMockNonMatchingIPNotifier creates a new mock instance.
func NewMockNonMatchingIPNotifier(ctrl *gomock.Controller) *MockNonMatchingIPNotifier {
	mock := &MockNonMatchingIPNotifier{ctrl: ctrl}
	mock.recorder = &MockNonMatchingIPNotifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNonMatchingIPNotifier) EXPECT() *MockNonMatchingIPNotifierMockRecorder {
	return m.recorder
}

// Notify mocks base method.
func (m *MockNonMatchingIPNotifier) Notify(ctx context.Context, dto domain.IPNotificationDTO) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Notify", ctx, dto)
	ret0, _ := ret[0].(error)
	return ret0
}

// Notify indicates an expected call of Notify.
func (mr *MockNonMatchingIPNotifierMockRecorder) Notify(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Notify", reflect.TypeOf((*MockNonMatchingIPNotifier)(nil).Notify), ctx, dto)
}
